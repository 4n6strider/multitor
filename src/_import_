#!/usr/bin/env bash

################################################################################
######################## Definitions of user variables #########################
################################################################################

export _cmdtime_state=0


################################################################################
######################## Definitions of user functions #########################
################################################################################

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _init_function()
#
# Description:
#   It deals with launching functions:
#     - creates a simple environment for the functions you perform
#     - operates on message to display and command to execute
#
# Usage:
#   _init_function function_name params
#
# Examples:
#   _init_function "CheckConn 172.20.20.50 22"
#

function _init_function() {

  local _FUNCTION_ID="_init_function"
  local _STATE=0

  local _args=("$@")

  local _cmd_begtime=0
  local _cmd_endtime=0
  local _cmd_totaltime=0

  _logger "info" \
    "${_FUNCTION_ID}()" \
    "init function: '${_args[*]}'"

  # In these two variables we store the message to display
  # and the command to execute.
  export _msg_args=()
  export _cmd_args=()

  eval "${_args[@]}" ; if [ ! $? ] ; then _exit_ 255 ; fi

  _num=${#_msg_args[@]}
  for (( _xa=0 ; _xa<=((_num - 1)) ; _xa++ )) ; do

    _msg="${_msg_args[$_xa]}"
    _full_command="${_cmd_args[$_xa]}"

    _sprintf "info" "$_msg"

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "$_msg"

    _cmd_begtime=$(date +%s)

    _init_cmd "$_full_command" ; if [ ! $? ] ; then _exit_ 255 ; fi

    _cmd_endtime=$(date +%s)

    # shellcheck disable=SC2154
    if [[ "$time_mode" -eq 1 ]] && [[ "$_cmdtime_state" -eq 1 ]] ; then

      _cmd_totaltime=$((_cmd_endtime - _cmd_begtime))

      _cmd_totaltime_out=$(printf '%dh:%dm:%ds' \
      $((_cmd_totaltime/3600)) $((_cmd_totaltime%3600/60)) $((_cmd_totaltime%60)))

      _sprintf "info" "time: $_cmd_totaltime_out"

      _logger "info" \
        "${_FUNCTION_ID}()" \
        "time: $_cmd_totaltime_out"

    fi

  done

  _cmdtime_state=0

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _dtorproc()
#
# Description:
#   It destroys currently running tor processes.
#
# Usage:
#   _dtorproc "proc_id"
#
# Examples:
#   _dtorproc "12500"
#

function _dtorproc() {

  local _FUNCTION_ID="_dtorproc"
  local _STATE=0

  local _arg_tproc="$1"

  kill -9 $_arg_tproc > /dev/null 2>&1 ; _kstate="$?"

  if [[ $_kstate -eq 0 ]] ; then

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "killed tor process: ${_tpr}"

      # Init _dtordatadir to removed tor process data directory.
      _init_function "_dtordatadir ${_tpr}"

  else

    _logger "warn" \
      "${_FUNCTION_ID}()" \
      "not killed tor process (maybe not found?)"

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _dtordatadir()
#
# Description:
#   It destroys currently tor processes data directory.
#
# Usage:
#   _dtordatadir "proc_id"
#
# Examples:
#   _dtordatadir "12500"
#

function _dtordatadir() {

  local _FUNCTION_ID="_dtordatadir"
  local _STATE=0

  local _arg_tdir="$1"

  cd "$_multitor_directory" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$_multitor_directory'"

  if [[ -d "$_arg_tdir" ]] ; then

    rm -fr "$_arg_tdir" && \
    _logger "info" \
      "${_FUNCTION_ID}()" \
      "removed tor process directory: ${_arg_tdir}"

  else

    _logger "warn" \
      "${_FUNCTION_ID}()" \
      "not found tor process directory"

  fi

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _ctorproc()
#
# Description:
#   It creates tor processes.
#
# Usage:
#   _ctorproc "username" "num" "num"
#
# Examples:
#   _ctorproc ${user_name} ${socks_port_number} ${control_port_number}
#

function _ctorproc() {

  local _FUNCTION_ID="_ctorproc"
  local _STATE=0

  local _arg_uname="$1"
  local _arg_socks="$2"
  local _arg_control="$3"

  _init_function "_ctordatadir"

  sudo -u $_arg_uname tor \
      --RunAsDaemon 1 \
      --CookieAuthentication 0 \
      --HashedControlPassword "" \
      --SocksPort $_arg_socks \
      --ControlPort $_arg_control \
      --PidFile "$_arg_socks.pid" \
      --DataDirectory "${_multitor_directory}/${_arg_socks}"

  return $_STATE

}

# ``````````````````````````````````````````````````````````````````````````````
# Function name: _ctordatadir()
#
# Description:
#   It creates tor processes data directory.
#
# Usage:
#   _ctordatadir
#
# Examples:
#   _ctordatadir
#

function _ctordatadir() {

  local _FUNCTION_ID="_ctordatadir"
  local _STATE=0

  cd "$_multitor_directory" || \
  _logger "stop" \
    "${_FUNCTION_ID}()" \
    "directory change error: '$_multitor_directory'"

  mkdir -m 0700 "$_arg_socks" > /dev/null 2>&1 ; _kstate="$?"

  if [[ $_kstate -eq 0 ]] ; then

    _logger "info" \
      "${_FUNCTION_ID}()" \
      "created tor process directory: ${_arg_socks}"

    chown -R "$_arg_uname": "${_arg_socks}" && \
    _logger "info" \
      "${_FUNCTION_ID}()" \
      "changed owner properly to: ${_arg_uname}" || \
    _logger "warn" \
      "${_FUNCTION_ID}()" \
      "the owner could not be changed"

  else

    _logger "warn" \
      "${_FUNCTION_ID}()" \
      "not created tor process directory"

  fi

  return $_STATE

}
